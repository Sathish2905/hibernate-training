# JPA annotations

## @Entity

* Annotated with `@Entity`
* Public or protected **no-argument** constructor
* Top-level class
* Not final class, no final methods or persistent instance variables
* Getters/setters for entity state properties
* Provide identifier attribute (**annotated with @Id**)

## @Table

This annotation is not required for entity :smile:

* Name of the entity define

```
@Table(name = """)
```

## @Id

* Not required to be the same as table primary key
* Should map to c
* Used to **
* Simple or 
* Immutable

2.

* Simple (single column)


```
class Actor {
  @Id
  Long id;
}
```

* Composite (multiple columns)

== composite primary key in database

```


```

3. 
* Assigned

Save operation fails if id is not set

```
class Actor {
  @Id
  Long id;
}
```

```
Actor actor = new Actor();
entityManager.persists(actor);
// IdentifierGenerationException

actor.setId(123L);
entityManager.persists(actor);
// Successfully saved

```

* Generated

If id is generated by database:

```
class Actor {
  @Id
  @GeneratedValue(strategy = IDENTITY)
  Long id;
}
```

```
Actor actor = new Actor();
// Successfully saved
entityManager.persists(actor);
```

## Generators

* AUTO (default) - Provider should choose a strategy
* IDENTITY - db generates id by itself
* SEQUENCE (default for Oracle and PostrgresQL) - db sequence should be used for obtaining primary key values
* TABLE - db table should be used. (Not really good, YOU should not use it)
 

## IDENTITY

Not good for batches

```
  for (int i = 0: i < 10; ++i) {
    Actor actor = new Actor();
    entityManager.persist(actor);
    // Identity is generated only when I create 
  }

```

## TABLE

Not good to use at all. (But it can work with batch update).

Hibernate requires hibernate_sequence table by default for id generation. It contains only nextVal.
As well as the following line: 

```
<property name="hibernate.hbm2ddl.auto">update</property>
```

```
  for (int i = 0: i < 10; ++i) {
    Actor actor = new Actor();
    entityManager.persist(actor);
    // Hibernate doesn't go to database for id generation 
  }

```

Custom sequence:

```
CREATE TABLE hibernate_sequences(sequence_name VARCHAR(40), next_val )
```

```
@GeneratedBalue(strategy = TABLE, generator = "actor_gen")
@TableGenerator(name = "actor_gen", initialValue = 2000, allocationSize = 50)
```

```
Go to 
```

## XXX

Sequence is quite native thing for databases, that use locks

If you use MYSQL - IDENTITY (if you want batching - do it with sql batching)

Use TABLE only for tests, not for production databases

If you use POSTGRES or ORACLE - SEQUENCE


## Composite key

```
@Entity
class FilmActor {

  @EmbeddedId
  PK id

  // Serializable is required for Hibernate 2-level cache
  @Embeddable
  static class PK implements Serializable {
    Long filmId;
    Long actorId;
  }

}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor.PK(20L, 10L));
```

OR

```
@Entity
@IdClass(FilmActorId.class)
class FilmActor {

  @Id
  Long filmId;

  @Id
  Long actorId;

  @Embeddable
  static class PK implements Serializable {
    Long filmId;
    Long actorId;
  }

}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor.PK(20L, 10L));
```

or 

```
@Entity
@IdClass(FilmActorId.class)
class FilmActor implements Serializable {

  @Id
  Long filmId;

  @Id
  Long actorId;
  
  public FilmActor(Long filmId, Long actorId) {
    this.filmId = filmId;
    this.actorId = actorId;
  }
}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor(20L, 10L));
```

But good is:

```
@Entity
class FilmActor implements Serializable {

  // One to one annotiations
  Film film;

  // One to one annotiations
  Actor actor;  
}
```

## ?

Equals and hashCode are required to be overiden.

But should equals check for id only?

```
class Actor {
  
  
  public boolean equals(Object o) {
    if (this == 0) return true;
    if (o == null || getClass() )
  }
  
  public int hashCode () {
    
  }
}
```

Case 1

```
Actor actor1 = entityManager.find(Actor.class, 17L);

Actor actor2 = entityManager.find(Actor.class, 17L);

actor1 == actor2

```

Case 2

```
Actor actor1 = entityManager.find(Actor.class, 17L);

// Clear 1st level cache
entityManager.clear();
Actor actor2 = entityManager.find(Actor.class, 17L);

actor1 == actor2

```

Case 3 - check by id only. trouble one. 

```
new Actor().equals(new Actor());
```

Case 4 - check by id only. trouble two.

If we use HashMap or HashSet, hash code should be defined by immutable fields!!!

```
Actor actor = new Actor();
actor3.setName("a");

Set<Actor> actorSet = new HashSet<>();
actorSet.add(actor3);

actorSet.contains(actor3); // returns TRUE!

entityManager.persist(actor3);
// Emulate ...?
entityManager.flush();

actorSet.contains(actor3); // returns FALSE!

```

See article - [Don't let hibernate steal your identity](http://www.onjava.com/pub/a/onjava/2006/09/13/dont-let-hibernate-steal-your-identity.html)