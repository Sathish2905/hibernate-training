# JPA annotations

## @Entity

Describes mapping between domain model object and table row

Requirements:
* Annotated with `@Entity`
* Must have public or protected **no-argument** constructor
* Top-level class (not inner class)
* Not final class, no final methods or persistent instance variables
* Getters/setters for entity state properties
* Provide identifier attribute (**annotated with @Id**)

```
// name argument can be used in hibernate queries
@Entity(name = "actor")
class Actor {
 
  @Id
  Long id;

}
```

## @Table

This annotation is not required for entity :smile:

* Name of the entity define

```
@Table(name = "table_name", schema = "schema_name", )
```

## @Id

* Uniquely identify each specific entity
* Not required to be the same as table primary key
* Should map to column that can uniquely identify each row
* Identifier is **immutable**

### Simple (single column) ID

```
class Actor {
  @Id
  Long id;
}
```

### Composite (multiple columns) ID

== composite primary key in database

```
@Entity
class FilmActor {

  @EmbeddedId
  PK id

  // Serializable is required for Hibernate 2-level cache
  @Embeddable
  static class PK implements Serializable {
    Long filmId;
    Long actorId;
  }

}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor.PK(20L, 10L));
```

OR

```
@Entity
@IdClass(FilmActorId.class)
class FilmActor {

  @Id
  Long filmId;

  @Id
  Long actorId;

  @Embeddable
  static class PK implements Serializable {
    Long filmId;
    Long actorId;
  }

}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor.PK(20L, 10L));
```

OR

```
@Entity
@IdClass(FilmActorId.class)
class FilmActor implements Serializable {

  @Id
  Long filmId;

  @Id
  Long actorId;
  
  public FilmActor(Long filmId, Long actorId) {
    this.filmId = filmId;
    this.actorId = actorId;
  }
}
```

```
  FilmActor actor = entityManager.find(FilmActor.class, new FilmActor(20L, 10L));
```

But good is:

```
@Entity
class FilmActor implements Serializable {

  // One to one annotiations
  Film film;

  // One to one annotiations
  Actor actor;  
}
```


### Assigned ID

Save operation fails if id is not set

```
class Actor {
  @Id
  Long id;
}
```

```
Actor actor = new Actor();
entityManager.persists(actor);
// IdentifierGenerationException

actor.setId(123L);
entityManager.persists(actor);
// Successfully saved

```

### Generated ID

Id is generated by database:

```
class Actor {
  @Id
  @GeneratedValue(strategy = IDENTITY)
  Long id;
}
```

```
Actor actor = new Actor();
// Successfully saved
entityManager.persists(actor);
```

# Generators


* AUTO (default) - Provider should choose a strategy
* IDENTITY - db generates id by itself (MYSQL, if batching is required - use sql batching)
* SEQUENCE (default for Oracle and PostrgresQL) - db sequence should be used for obtaining primary key values. Native for db.
* TABLE - db table should be used. (Not really good, YOU should not use it. Only for demo)
 

## IDENTITY

DB generates ID. (Default for MYSQL).
Not good for batches

```
  for (int i = 0: i < 10; ++i) {
    Actor actor = new Actor();
    entityManager.persist(actor);
    // Identity is generated only when I create 
  }

```

## TABLE

Not good to use at all. (But it can work with batch update).

Hibernate requires `hibernate_sequence` table by default for id generation. It contains only `nextVal` column.

The following line will create this table for us.

```
<property name="hibernate.hbm2ddl.auto">update</property>
```

Example of batch update.

```
  for (int i = 0: i < 10; ++i) {
    Actor actor = new Actor();
    entityManager.persist(actor);
    // Hibernate doesn't go to database for id generation 
  }

```

Custom sequence:

```
CREATE TABLE hibernate_sequences(sequence_name VARCHAR(40), next_val )
```

```
@GeneratedBalue(strategy = TABLE, generator = "actor_gen")
@TableGenerator(name = "actor_gen", initialValue = 2000, allocationSize = 50)
```

```
Go to 
```